# Artifact for "Escape with Your Self: Sound and Expressive Bidirectional Typing with Avoidance for Reachability Types"

This document serves as the Artifact Overview.

We sincerely thank the reviewers for their time and effort in evaluating our work.
We hope the formalization and checked examples are useful for help understand, validate, and extend our work described in our paper.

## Introduction

This artifact supports the following contribution in the paper.

| Claim                                                                    | Supported? | How                                  |
| -------                                                                  | ---------- | --------                             |
| Type system $G_{<:}^{♦}$ with self-aware subtyping and qualifier holes   | Yes        | Fully mechanized in `LangRules.lean` |
| Bidirectional Typing Algorithm $G_{\leftrightharpoons}^{♦}$              | Yes        | Fully mechanized in `Checking.lean`  |
| Examples (e.g. church-encoded pairs, lists)                              | Yes        | Mechanized in `ChkExamples.lean`     |
| Experiment Results                                                       | Yes        | Generated by `data.py`               |


The document includes:
- Build instructions and dependencies (See [Getting-Started-Guide](#getting-started-guide))
- File Organization of this Artifact (See [File Organization](#file-organization))
- Documentation mapping paper presentation to formal mechanization (See [Paper-to-Artifact Correspondence](#paper-to-artifact-correspondence))
- Documentation of examples (See [Examples](#examples))
- Reusability Guide (See [Reusability-Guide](#reusability-guide))


## Getting Started Guide

We provide either a docker containing the artifact and the build-from-scratch approach.

### Quick Start with Docker

#### 1. Fetch the latest docker image
Fetch by Cmd:
```
  docker pull jia137/rt-checking
```

Or download the attached `rt-checking.tar` and load in Cmd by:
```
  docker load -i rt-checking.tar
```

#### 2. Run the docker image
Run image by Cmd:
```
  docker run -it --rm jia137/rt-checking
```

#### 3. Build the Lean proofs
Build by Cmd:
```
  lake exe cache get
  lake build
```

If the build is successfully, you will see a message "Build complete successfully." and the axioms.

#### 4. Generate Data and Plot
Run by Cmd:
```
  python3 data.py --fig-file plot.png
```

Python will print a table of data, and save the plot to `plot.png`.

### Build from Scratch

- **Python libraries**: python 3.12.3 on Ubuntu 24.04, matplotlib 3.6.3, numpy 1.26.4

The version control has already been set in `lakefile.toml`, `lean-toolchain`.

Python3 is only for figures.

### Installation Guide

#### 1. Install Lean 

Following the official guide: https://lean-lang.org/lean4/doc/setup.html#setting-up-lean 

**Lean version** guaranteed to work: lean4:v4.14.0

The version control has already been set in `lakefile.toml`, `lean-toolchain`.

#### 2. Build the Artifact

Build by Cmd:
```
  lake exe cache get
  lake build
```

Or interact in VSCode:
- Open `Lean4/Examples.lean` (for example) and click `Restart File` from Lean4 menu bar.

#### 3. Generate Data and Plot

We test on the following **Python environment**:
  - python 3.12.3 on Ubuntu 24.04, matplotlib 3.6.3, numpy 1.26.4

_Note_: different python and library versions are not guaranteed to work.

Run by Cmd:
```
  python3 data.py --fig-file plot.png
```

Python will print a table of data, and save the plot to `plot.png`.

## File Organization

| File Name         | Description                                           |
| ----              | ----                                                  |
| `Attrs.lean`      | includes                                              |
| `LangDefs.lean`   | basic qualifier definitions, operations, and contexts |
| `LangLemmas.lean` | auxiliary lemmas                                      |
| `LangRules.lean`  | implementation of type system                         |
| `LR.lean`         | definition of logical relations                       |
| `LRSound.lean`    | metatheory of type system                             |   
| `Checking.lean`   | implementation of checking algorithm                  |
| `ChkTheorems.lean`| metatheory of checking algorithms                     |
| `ChkExamples.lean`| checking examples                                     |

## Paper-to-Artifact Correspondence

### The Type System $G_{<:}^{♦}$

| **Paper**                     | **Lean Definition** | **Lean File**     |
| ----                          | ----                | ----              |
| Well-formed Qualifier (Fig.2) | `closed_ql`         | `LangDefs.lean`   |
| Well-formed Type (Fig.2)      | `closed_ty`         | `LangDefs.lean`   |
| Occurrence Predicate (Fig.2)  | `occurs`            | `LangDefs.lean`   |
| Well-formed Context (Fig.2)   | `telescope`         | `LangDefs.lean`   |
| Term Typing (Fig.3)           | `has_type`          | `LangRules.lean`  |
| Subqualifying (Fig.4)         | `qtp`               | `LangRules.lean`  |
| Self-Aware Subtyping (Fig.4)  | `stp`               | `LangRules.lean`  |
| Context Subsumption (Fig.5)   | `ctx_grow`          | `LangRules.lean`  |


_Note_: Deviations from the Paper:
1. **Application Conformance** and **Surface Subtyping**: inlined in the places where they are used.
2. **Qualifier Holes**: formalized differently from the paper.
  Qualifier holes are not defined as part of the qualifiers, but recorded as
  an extra field of the type `gfset` (often named `gs`), which
  is attached to the definitions `qtp`, `stp`, `has_type`, and `ctx_grow`.
  If a variable is in `gs`, its associated qualifier in the context contains a qualifier hole.

### Metatheory of $G_{<:}^{♦}$

| **Paper**                 | **Lean Lemma**        | **Lean File**    |
| ----                      | ----                  | ----             |
| Fundamental (3.1)         | `fundamental`         | `LRSound.lean`   |
| Type Safety (3.2)         | `type_safety`         | `LRSound.lean`   |
| Context Subsumption (3.3) | `ctx_grow.on_hastype` | `LangRules.lean` |
| Hole Insertion (3.4)      | `has_type.gs_tighten` | `LangRules.lean` |

_Note_: Deviations from the Paper:
1. The Hole Insertion lemma mechanized supports removing multiple holes at the
  same time, while the version presented in the paper removes one at a time.



### The Bidirectional Algorithm $G_{\leftrightharpoons}^{♦}$

| **Paper**                           | **Lean Definition**                                 | **Lean File**   |
| ----                                | ----                                                | ----            |
| Qualifier Exposure (Fig.6)          | `qsatself` ($\Uparrow_1$), `qbounded` ($\Uparrow_2$)| `Checking.lean` |
| Qualifier Checking (Fig.6)          | `check_qtp0`                                        | `Checking.lean` |
| Qualifier Unification (Fig.6)       | `qunify`                                            | `Checking.lean` |
| Qualifier Inference (Fig.6)         | `check_qtp`                                         | `Checking.lean` |
| Self Unpacking (Fig.7)              | `unpack_self`                                       | `Checking.lean` |
| Recursive Subtype Checking (Fig.7)  | `check_stp2`                                        | `Checking.lean` |
| Toplevel Subtype Checking (Fig.7)   | `check_stp`                                         | `Checking.lean` |
| Polarized Substitution (Fig.8)      | `polsub`                                            | `Checking.lean` |
| Avoidance Core (Fig.8)              | `avoid`                                             | `Checking.lean` |
| Application Avoidance (Fig.8)       | `avoid_app`                                         | `Checking.lean` |
| Type Exposure (Fig.9)               | `texposure`                                         | `Checking.lean` |
| Bidirectional Typing (Fig.9)        | `tinfer`, `tcheckq`, `tcheck` mutually              | `Checking.lean` |
| Application Conformance (Fig.9)     | `check_app`                                         | `Checking.lean` |

_Note_: Deviations from the Paper:
1. Recursive subtype checking `check_stp2` is defined with an additional argument of `fuel`.
  The argument is used to ensure the termination at definition site.
  We prove an auxiliary lemma `check_stp2_fuel`, so there is a deterministic way
  to initialize fuel that ensures the termination of `check_stp2`.


### Metatheory of $G_{\leftrightharpoons}^{♦}$

_Note_: The **decidability** are proven in-place with definition, the decreasing measurements are followed by the `termination_by` and proofs followed by the `decreasing_by` if not trivial.

| **Paper**                               | **Lean Lemma**                              | **Lean File**      |
| ----                                    | ----                                        | ----               |
| Soundness of Qualifier Checking (4.1)   | `check_qtp0_sound`                          | `ChkTheorems.lean` |
| Completeness of Qualifier Checking (4.2)| `check_qtp0_complete`                       | `ChkTheorems.lean` |
| Soundness of Unification (4.3)          | `qunify_sound`                              | `ChkTheorems.lean` |
| Soundness of Qualifier Inference (4.4)  | `check_qtp_sound`                           | `ChkTheorems.lean` |
| No Principle Qualifier Difference (4.5) | `qdiff_nonprincipal`                        | `ChkTheorems.lean` |
| Equivalence of Self Unpacking (4.6)     | `unpack_self_equiv`                         | `ChkTheorems.lean` |
| Soundness of Subtype Checking (4.7)     | `check_stp_sound`                           | `ChkTheorems.lean` |
| Soundness of Avoidance (4.8)            | `avoid_preserves_closedness`, `avoid_sound` | `ChkTheorems.lean` |
| Minimality of Outermost Avoidance (4.9) | `avoid_fg_example`                          | `ChkTheorems.lean` |
| Soundness of Type Exposure (4.10)       | `texposure_sound`                           | `ChkTheorems.lean` |
| Soundness of Bidirectional Typing (4.11)| `bidirectional_sound`                       | `ChkTheorems.lean` |


## Examples

The examples are encoded in `ChkExamples.lean`.

| **Example**               | **Section in Lean**     | **Paper** |
| ----                      | ----                    | ----      |
| Church booleans           | `Church_Bool`           | /         |
| Church numerals           | `Church_Nat`            | /         |
| Safe Parallelism          | `safepar`               | Section 1 | 
| Controlling Capabilities  | `effectcapability`      | Section 1 |
| Church pairs              | `escapingpairs`         | Section 5 |
| Church lists              | `lists`                 | Section 1 |
| Church lists (separate)   | `seplists`              | Section 1 |
| Encoding Stateful Objects | `separation`            | Section 1 |
| Loop on Church numerals   | `natloop`               | /         |

_Note_: `#eval check_program` runs the checking for a program.

The experiment results in Section 5.1 can be generated from running the `data.py`.


## Reusability Guide

### Axioms

The axioms are printed in `Lean4.lean` in the root directory. These axioms are common, and can be found in the official documentation.
- `propext`: [propositional extensionality](https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#propext)
- `Classical.choice`: [axiom of choice](https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Classical.choice)
- `Quot.sound`: [quotient axiom](https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#Quot.sound)


### Reusability

The following components are reusable and extensible for future research:
- `LangDefs.lean`, `LangRules.lean`, `LangLemmas.lean`: contain the declarative type system, suitable for extending with new constructs.
- `LR.lean`, `LRSound.lean`: contain semantic soundness results and the proof framework.
- `Checking.lean`, `ChkTheorems.lean`: contain implementation and metatheory of the checking algorithm, suitable for extending with new constructs.
- `ChkExamples.lean`: contain a front-end language, checked examples and facilities, suitable for templates of new examples.

To add new constructs to the language, extend the `has_type` in `LangRules.lean`, then adapt changes to the checking algorithm and proofs accordingly. 

To check a new example, follow the structure of an arbitrary section in `ChkExamples.lean` (e.g., `lists`).